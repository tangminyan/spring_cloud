Java I/O 涉及到的类也确实特别多，不仅有分别用于操作字符流和字节流的 InputStream 和 Reader、OutputStream 和 Writer，
还有什么 BufferedInputStream、BufferedReader、PrintWriter、PrintStream等，还有用于沟通字节流和字符流的桥梁 InputStreamReader 和 OutputStreamWriter，
每一个类都有其不同的应用场景，如此细致的划分，光是名字就足够让人晕头转向了。

我一直记不住 Java I/O 中各种细节的另一个原因可能是我深受 ANSI C 的荼毒吧。在 C 语言的标准库中，将文件的打开方式分为两种，
一种是将文件当成二进制格式打开，一种是当成文本格式打开。这和 Java 中的字节流和字符流的划分有相似之处，但却掩盖了所有的数据其实都是字节流这样的本质。
ANSI C 用多了，总以为二进制格式和文本格式是同一个层面的两种对立面，只能对立而不能统一，却不知在 Java 中，字符流是对字节流的更高层次的封装，
最底层的 I/O 都是建立在字节流的基础上的。如果抛开 ANSI C 语言的标准 I/O 库，直接考察操作系统层面的 POSIX I/O，会发现操作的一切都是原始的字节数据，
根本没有什么字节字符的区别。

　　除此之外，Java 走得更远，它考虑到了各种更加广泛的字节流，而不仅仅限于文件。比如网络中传输的数据、内存中传输的对象等等，
都可以用流来抽象。但是不同的流具有不同的特性，有的流可以随机访问，而有的却只能顺序访问，有的可以解释为字符，有的不能。在能解释为字符的流中，
有的一次只能访问一个字符，有的却可以一次访问一行，而且把字节流解释成字符流，还要考虑到字符编码的问题。

　　以上种种，均是造成 Java I/O 中类和接口多、对象构造方式复杂的原因。